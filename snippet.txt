Git Debug tools

Everyone knows Git as a great file versioning tool. But did you know you can also use Git to debug and to help you find bugs in your code?

In this snippet, I'll explain about two tools that helps me a lot and how I use then. The tools are: git blame and git bisect. We can use them in different scenarios and together.

Git blame

Git blame is a well know tool, basically, you can use to check what commit modify certain line of code. The first column is the partial commit hash followed by user, date, time, time zone, line number, line content.

Let's start with a simple example, In the following example, the tool is used in the README.md file.

$ git blame README.md
406b2818 (Jonathan 2017-12-05 15:49:16 -0200 1) #Git Debugging
406b2818 (Jonathan 2017-12-05 15:49:16 -0200 2)
06c430e2 (Jonathan 2017-12-05 16:14:49 -0200 3) This project is part of an article made for Avenue Code Snippets.
d44487fe (Jonathan 2017-12-05 15:57:23 -0200 4)
d44487fe (Jonathan 2017-12-05 15:57:23 -0200 5) ##Project content
d44487fe (Jonathan 2017-12-05 15:57:23 -0200 6)
06c430e2 (Jonathan 2017-12-05 16:14:49 -0200 7) Basic Rest based crud with Spring Boot.

In code above we can check 3 different commits (406b2818, 06c430e2, d44487fe), followed by commiter data and finally the line content.

There are a lot of options that you can use with git blame. You can see all git blame options in the official documentation (see section Links).

One important option is [-L <range>]. With this option you can check just some lines of your file. Let's see an example:

$ git blame -L 2,8 README.md
406b2818 (Jonathan          2017-12-05 15:49:16 -0200 2)
06c430e2 (Jonathan          2017-12-05 16:14:49 -0200 3) This project is part of an article made for Avenue Code Snippets.
d44487fe (Jonathan          2017-12-05 15:57:23 -0200 4)
00000000 (Not Committed Yet 2017-12-05 16:54:00 -0200 5) This is a unstaged change
00000000 (Not Committed Yet 2017-12-05 16:54:00 -0200 6)
d44487fe (Jonathan          2017-12-05 15:57:23 -0200 7) ##Project content
d44487fe (Jonathan          2017-12-05 15:57:23 -0200 8)

In the example we filter the file, starting from line 2 to line 8. Note that 'blame' also shows uncommited changes.

Another interesting option is [-C], especially when you are refactoring a code. Summing up when you use [-C] Git try to find code blocks that was moved from another file. In this piece of code there is a simple endpoint using Java and SpringBoot.

package edu.ac.gitdebugging;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class App {
	public static void main(String[] args) {
		SpringApplication.run(App.class, args);
	}

	@RequestMapping("/sayHello")
	public String sayHello() {
		return "Hello";
	}
}

Then I decide to move the method sayHello to a new file called MainController, like the following code.

package edu.ac.gitdebugging.web;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MainController {
	@RequestMapping("/sayHello")
	public String sayHello() {
		return "Hello";
	}
}

Now if we use blame with -C option in new class we got:

$ git blame -C src/main/java/edu/ac/gitdebugging/web/MainController.java
00000000 src/main/java/edu/ac/gitdebugging/web/MainController.java (Not Committed Yet 2017-12-05 18:27:29 -0200  1) package edu.ac.gitdebugging.web;
00000000 src/main/java/edu/ac/gitdebugging/web/MainController.java (Not Committed Yet 2017-12-05 18:27:29 -0200  2)
62394f5c src/main/java/edu/ac/gitdebugging/App.java                (Jonathan          2017-12-05 18:20:27 -0200  3) import org.springframework.web.bind.annotation.RequestMapping;
62394f5c src/main/java/edu/ac/gitdebugging/App.java                (Jonathan          2017-12-05 18:20:27 -0200  4) import org.springframework.web.bind.annotation.RestController;
62394f5c src/main/java/edu/ac/gitdebugging/App.java                (Jonathan          2017-12-05 18:20:27 -0200  5)
00000000 src/main/java/edu/ac/gitdebugging/web/MainController.java (Not Committed Yet 2017-12-05 18:27:29 -0200  6) @RestController
00000000 src/main/java/edu/ac/gitdebugging/web/MainController.java (Not Committed Yet 2017-12-05 18:27:29 -0200  7) public class MainController {
62394f5c src/main/java/edu/ac/gitdebugging/App.java                (Jonathan          2017-12-05 18:20:27 -0200  8)     @RequestMapping("/sayHello")
62394f5c src/main/java/edu/ac/gitdebugging/App.java                (Jonathan          2017-12-05 18:20:27 -0200  9)     public String sayHello() {
62394f5c src/main/java/edu/ac/gitdebugging/App.java                (Jonathan          2017-12-05 18:20:27 -0200 10)             return "Hello";
62394f5c src/main/java/edu/ac/gitdebugging/App.java                (Jonathan          2017-12-05 18:20:27 -0200 11)     }
^5f1231c src/main/java/edu/ac/gitdebugging/App.java                (Jonathan          2017-12-05 15:39:16 -0200 12) }

How you can see, this class is not commited yet, and we have a new column in result. The new column shows where the code originally comes from.

IDEs like Eclipse and Intellij have a built-in 'blame' integrated with the code editor. In eclipse, right click in the line number and 'Show revision information'. In Intellij right click in the line number and 'Annotate'.


Git bisect


The first tool shows who, when and what commit make the change in the code. In most of time you don't have idea what is breaking your code, git bisect can be used for this cases. Before givingv some usage tips, let's go to the basics.

Git bisect stands for git binary search. In a nutshell, git bisect find what exactly commit introduced a bug.

Before show the example, let's get a simple review about binary search.

First of all, why binary search? Can we just start in newest commit to the oldest commit?

Imagine that you have ten thousand of commits, and the bug is in the second commit, but never was discovered or exposed. Very often there bugs that always have been in the project (some of them since the first commit). This process will take so long to complete.

The main idea of binary search is simple, given a collection of elements (e.g ordered integer array), we go the middle point of the collection, with the middle element we check if is this element that we are searching about; if not, then we need if we go to search in the group of elements right or left of the middle point. With this new groups we keep iterating this steps until we find the element.

Applying to our scenario: Git search trough all commits starting in the middle commit in commits stack. With the middle commit, you need to inform Git if in this point the bug still occurs. If the bug is not present, then the git bisect create a group with the commits before (newer) that one. It continues searching until it finds the exact commit that introduced the bug.

Let's see the following example. First, let's check our commit stack:




Links

Git Blame:
https://git-scm.com/docs/git-blame

The examples are based in following repository:
https://github.com/JonathanOhara/gitdebugging
